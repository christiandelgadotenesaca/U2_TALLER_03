const httpMocks = require('node-mocks-http');
const paginationMiddleware = require('./pagination');
const sinon = require('sinon');

describe('pagination middleware', () => {

  it('parsing query page/ps', () => {
    const req = httpMocks.createRequest({
      method: 'GET',
      url: '/pagination',
      query: {
        page: 2,
        ps: 12
      }
    });
    req.meta = {};


    const res = httpMocks.createResponse();

    paginationMiddleware(req, res, () => {});

    expect(req.meta.paginator.offset).to.equal(12);
    expect(req.meta.paginator.limit).to.equal(12);

  });

  it('parsing without query, should not paging', () => {
    const req = httpMocks.createRequest({
      method: 'GET',
      url: '/pagination'
    });
    req.meta = {};

    const res = httpMocks.createResponse();

    paginationMiddleware(req, res, () => { });

    expect(req.meta.paginator).to.be.undefined;

    expect(res.paged).to.be.undefined;
  });

  it('inject res.paged method', () => {
    const req = httpMocks.createRequest({
      method: 'GET',
      url: '/pagination',
      query: {
        page: 2,
        ps: 12
      }
    });
    req.meta = {};

    const res = httpMocks.createResponse();

    expect(res.paged).not.to.be.a('function');

    paginationMiddleware(req, res, () => { });

    expect(res.paged).to.be.a('function');
  });

  it('pagination response', () => {
    const req = httpMocks.createRequest({
      method: 'GET',
      url: '/pagination',
      query: {
        page: 1,
        ps: 10
      }
    });
    req.meta = {};


    const res = httpMocks.createResponse();
    const mock = sinon.spy();
    res.data = mock;
    const rows = [{ haha: 'good'}];
    const count = 11;

    const next = (err, req, res) => {
      return res.paged({
        count,
        rows
      });
    };

    paginationMiddleware(req, res, next);

    expect(mock).to.have.been.called;
    expect(mock).to.have.been.calledWith({
      count,
      rows,
      page: 1
    });
  });

  it('pagination query a over-large page(请求中的页码过大), 结果中应响应回正确的页码', () => {
    const req = httpMocks.createRequest({
      method: 'GET',
      url: '/pagination',
      query: {
        page: 3,
        ps: 10
      }
    });
    req.meta = {};

    const res = httpMocks.createResponse();

    const mock = sinon.spy();
    res.data = mock;
    const rows = [{ haha: 'good' }];
    const count = 12;

    const next = (err, req, res) => {
      return res.paged({
        count,
        rows
      });
    };

    paginationMiddleware(req, res, next);

    expect(mock).to.have.been.called;
    expect(mock).to.have.been.calledWith({
      count,
      rows,
      page: 2
    });
  });
});

